/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => NewHeadingShortcutPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  defaultHeaderLevel: 1,
  addSpaceAfterHash: true
};
var NewHeadingShortcutPlugin = class extends import_obsidian.Plugin {
  async onload() {
    await this.loadSettings();
    this.addCommand({
      id: "add-sibling-header",
      name: "Add New Contextual Header (Sibling)",
      editorCallback: (editor, view) => {
        this.addSiblingHeader(editor);
      }
    });
    this.addCommand({
      id: "add-child-header",
      name: "Add New Contextual Header (Child)",
      editorCallback: (editor, view) => {
        this.addChildHeader(editor);
      }
    });
    this.addCommand({
      id: "add-parent-header",
      name: "Add New Contextual Header (Parent)",
      editorCallback: (editor, view) => {
        this.addParentHeader(editor);
      }
    });
    this.addSettingTab(new NewHeadingShortcutSettingTab(this.app, this));
  }
  onunload() {
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  findLastHeaderLevel(editor) {
    const cursorPosition = editor.getCursor();
    const linesUntilCursor = editor.getValue().split("\n").slice(0, cursorPosition.line + 1);
    const contentUntilCursor = linesUntilCursor.join("\n");
    const headings = contentUntilCursor.match(/^#+ /gm);
    if (headings && headings.length > 0) {
      const lastHeading = headings[headings.length - 1];
      return lastHeading.match(/^#+/)[0].length;
    }
    return this.settings.defaultHeaderLevel;
  }
  addSiblingHeader(editor) {
    const headerLevel = this.findLastHeaderLevel(editor);
    this.insertHeader(editor, headerLevel);
  }
  addChildHeader(editor) {
    const headerLevel = this.findLastHeaderLevel(editor);
    const childLevel = Math.min(headerLevel + 1, 6);
    this.insertHeader(editor, childLevel);
  }
  addParentHeader(editor) {
    const headerLevel = this.findLastHeaderLevel(editor);
    const parentLevel = Math.max(headerLevel - 1, 1);
    this.insertHeader(editor, parentLevel);
  }
  insertHeader(editor, level) {
    const cursor = editor.getCursor();
    const headerPrefix = "#".repeat(level);
    const space = this.settings.addSpaceAfterHash ? " " : "";
    const newlinePrefix = cursor.line === 0 && cursor.ch === 0 ? "" : "\n";
    const headerText = `${newlinePrefix}${headerPrefix}${space}`;
    editor.replaceRange(headerText, cursor);
    const newCursorPos = {
      line: cursor.line + (newlinePrefix ? 1 : 0),
      ch: headerText.length - (newlinePrefix ? 1 : 0)
    };
    editor.setCursor(newCursorPos);
  }
};
var NewHeadingShortcutSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  openHotkeySettings(commandName) {
    this.app.setting.openTabById("hotkeys");
    const tab = this.app.setting.activeTab;
    if (tab && tab.searchComponent && tab.searchComponent.inputEl) {
      tab.searchComponent.inputEl.value = commandName;
      tab.updateHotkeyVisibility();
    }
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "New Heading Shortcut Settings" });
    const descEl = containerEl.createEl("div", { cls: "setting-item-description" });
    descEl.innerHTML = `
			<p>This plugin intelligently creates headers based on the most recent header in your document. It analyzes your document content up to the cursor position and determines the appropriate header level.</p>
			<ul>
				<li><strong>Sibling Header:</strong> Creates a header at the same level as the most recent header</li>
				<li><strong>Child Header:</strong> Creates a header one level deeper (e.g., ## becomes ###)</li>
				<li><strong>Parent Header:</strong> Creates a header one level higher (e.g., ### becomes ##)</li>
			</ul>
		`;
    descEl.style.marginBottom = "20px";
    descEl.style.padding = "10px";
    descEl.style.backgroundColor = "var(--background-secondary)";
    descEl.style.borderRadius = "5px";
    containerEl.createEl("h3", { text: "Hotkey Configuration" });
    const hotkeyDesc = containerEl.createEl("p");
    hotkeyDesc.textContent = "Configure hotkeys for quick access to each command. Click the buttons below to open the hotkey assignment dialog.";
    hotkeyDesc.style.marginBottom = "15px";
    hotkeyDesc.style.color = "var(--text-muted)";
    new import_obsidian.Setting(containerEl).setName("Add Sibling Header").setDesc("Creates a header at the same level as the most recent header").addExtraButton((button) => button.setIcon("any-key").setTooltip("Configure Hotkey").onClick(() => {
      this.openHotkeySettings("Add New Contextual Header (Sibling)");
    }));
    new import_obsidian.Setting(containerEl).setName("Add Child Header").setDesc("Creates a header one level deeper than the most recent header").addExtraButton((button) => button.setIcon("any-key").setTooltip("Configure Hotkey").onClick(() => {
      this.openHotkeySettings("Add New Contextual Header (Child)");
    }));
    new import_obsidian.Setting(containerEl).setName("Add Parent Header").setDesc("Creates a header one level higher than the most recent header").addExtraButton((button) => button.setIcon("any-key").setTooltip("Configure Hotkey").onClick(() => {
      this.openHotkeySettings("Add New Contextual Header (Parent)");
    }));
    containerEl.createEl("h3", { text: "General Settings" });
    new import_obsidian.Setting(containerEl).setName("Default header level").setDesc("The header level to use when no previous headers are found in the document").addSlider((slider) => slider.setLimits(1, 6, 1).setValue(this.plugin.settings.defaultHeaderLevel).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.defaultHeaderLevel = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Add space after hash").setDesc("Add a space after the # symbols in the header").addToggle((toggle) => toggle.setValue(this.plugin.settings.addSpaceAfterHash).onChange(async (value) => {
      this.plugin.settings.addSpaceAfterHash = value;
      await this.plugin.saveSettings();
    }));
  }
};
